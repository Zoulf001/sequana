# coding: utf-8
#
#  This file is part of Sequana software
#
#  Copyright (c) 2016 - Sequana Development Team
#
#  File author(s):
#      Dimitri Desvillechabrol <dimitri.desvillechabrol@pasteur.fr>,
#          <d.desvillechabrol@gmail.com>
#
#  Distributed under the terms of the 3-clause BSD license.
#  The full license is in the LICENSE file, distributed with this software.
#
#  website: https://github.com/sequana/sequana
#  documentation: http://sequana.readthedocs.io
#
##############################################################################
"""
Author: Quentin Letourneur / Thomas Cokelaer
Affiliation: Institut Pasteur
Aim: WES QC
Data: paired end or single reads
Run: snakemake -s wes_qc.rules
"""
import os

import sequana
from sequana import snaketools as sm
from sequana.snaketools import SequanaConfig

exec(open(sequana.modules["fastqc_dynamic"], "r").read())

sm.init("wes_qc.rules", globals())
expected_output = []
# This must be defined before the include
configfile: "config.yaml"
manager = sm.PipelineManager("wes_qc", config)

# Clean template and replace None with empty string
config = manager.config
__snakefile__ = srcdir(__snakefile__)
__rawdata__input = manager.getrawdata()
__report_dir__ = 'report_vc_{0}'.format(manager.sample)


#
# Preprocessing for variant calling
#
# - Reads QC : FastQC
# - Mapping: BWA
# - Sort: sambamba
# - MarkDuplicates: sambamba
# - Quality filter: samtools
#
##############################################################################

if manager.config.fastqc.do_raw:
    __fastqc_samples__input_fastq = __rawdata__input
    __fastqc_samples__output_done = manager.getname("fastqc_samples", ".done")
    __fastqc_samples__wkdir       = manager.getwkdir("fastqc_samples")
    __fastqc_samples__log = "%s/fastqc_samples/fastqc.log" % manager.sample
    include: fastqc_dynamic("samples", manager)
    expected_output.extend(expand(__fastqc_samples__output_done, sample=manager.samples))


reference = config["bwa_mem_ref"]["reference_file"]
exec(open(sequana.modules["dynamic_copy"], "r").read())
__copy_ref__input = reference
__copy_ref__output = "reference/" + os.path.basename(reference)
include: dynamic_copy("ref", manager)
__bwa_mem_ref__reference = __copy_ref__output

# The pipeline can be started with sorted BAM files
if config['input_pattern'].endswith('bam'):
    __bwa_mem_ref__fai = __bwa_mem_ref__reference + ".fai"
    __bwa_mem_ref__bam = __rawdata__input
else:
    # Mapping with BWA MEM
    exec(open(sequana.modules["bwa_mem_dynamic"], "r").read())
    __bwa_mem_ref__fastq = __rawdata__input
    __bwa_mem_ref__fai = __bwa_mem_ref__reference + ".fai"
    __bwa_mem_ref__bam = manager.getname("bwa_mem_ref", ".sorted.bam")
    __bwa_mem_ref__log = manager.getlogdir("bwa_mem_ref")
    __bwa_index_ref__log = "common_logs/bwa_index.log"
    include: bwa_mem_dynamic("ref", manager)

# Add read groups of sample
__add_read_group__input = __bwa_mem_ref__bam
__add_read_group__output = manager.getname("add_read_group", ".rg.sorted.bam")
__add_read_group__log_err = manager.getlogdir("add_read_group.err")
__add_read_group__log_std = manager.getlogdir("add_read_group.std")
__add_read_group__rg = "ID=%s LB=%s PL=%s PU=%s SM=%s" % (
    manager.sample, manager.sample, manager.config.sequencing.platform,
    manager.config.sequencing.flowcell, manager.sample)
include: sm.modules["add_read_group"]

# Init all input of next rules. These rules are optional and can be inactivate
# in the config file with the "do" option.
__sambamba_markdup__input = __add_read_group__output
__sambamba_filter__input = __add_read_group__output
__samtools_depth__input = __add_read_group__output
__freebayes__input = __add_read_group__output

# Mark duplicates with sambamba markdup
if config["sambamba_markdup"]["do"]:
    __sambamba_markdup__output = manager.getname("sambamba_markdup",
                                                ".rmdup.sorted.bam")
    __sambamba_markdup__log_err = manager.getlogdir("sambamba_markdup.err")
    __sambamba_markdup__log_std = manager.getlogdir("sambamba_markdup.std")
    include: sm.modules["sambamba_markdup"]
    __sambamba_filter__input = __sambamba_markdup__output
    __freebayes__input = __sambamba_markdup__output
    __samtools_depth__input = __sambamba_markdup__output

# bam quality filter with sambamba
if config["sambamba_filter"]["do"]:
    __sambamba_filter__output = manager.getname("sambamba_filter",
                                                ".filter.sorted.bam")
    __sambamba_filter__log = manager.getlogdir("sambamba_filter")
    include: sm.modules["sambamba_filter"]
    __freebayes__input = __sambamba_filter__output
    __samtools_depth__input = [
        __sambamba_filter__output,
        __sambamba_filter__input,
    ]

#
# Coverage analysis
#
##############################################################################

# Sequana_coverage analysis
if config["sequana_coverage"]["do"]:
    __samtools_depth__output = manager.getname("samtools_depth", ".bed")
    __samtools_depth__log = manager.getlogdir("samtools_depth")
    include: sm.modules["samtools_depth"]
    __sequana_coverage__bed = __samtools_depth__output
    __sequana_coverage__fasta = __bwa_mem_ref__reference
    if config['snpeff']['do']:
        __sequana_coverage__gbk = config['snpeff']['reference_file']
    else:
        __sequana_coverage__gbk = []
    __sequana_coverage__csv = manager.getname("sequana_coverage", ".csv")
    __sequana_coverage__report_dir = __report_dir__
    __sequana_coverage__html = os.sep.join([
        __report_dir__, 'sequana_coverage.html'
    ])
    include: sm.modules["sequana_coverage"]
    expected_output.append(expand(__sequana_coverage__csv,
                                  sample=manager.samples))


#
# Variant calling
# - Calling: freebayes
# - annotation: snpEff
# - filter: sequana
#
##############################################################################

# Variant calling with Freebayes
# bai file is setup in freebayes rule for pipeline summary
__freebayes__reference = __bwa_mem_ref__reference
__freebayes__output = manager.getname("freebayes", ".raw.vcf")
__freebayes__log = manager.getlogdir("freebayes")
include: sm.modules["freebayes"]




#
# Utils
#
##############################################################################

# Create requirements.txt(dependencies)
__conda__output = "requirements.txt"
include: sm.modules["conda"]
expected_output.extend([__conda__output])


# Create rulegraph
__rulegraph__input = __snakefile__
__rulegraph__output = "rulegraph/rulegraph.svg"
__rulegraph__mapper = {
    "sequana_coverage": "../sequana_coverage.html",
}
if len(manager.samples) > 1:
    __rulegraph__mapper['joint_freebayes_vcf_filter'] = '../joint_calling.html'
include: sm.modules["rulegraph"]
expected_output.extend(["requirements.txt", __rulegraph__output])



# these rules don't need to be submit on a node.
# snpeff_download_database needs an internet connection
localrules: conda, rulegraph

################################################################################
# multiqc_report
__multiqc__output = "multiqc_report.html"

from sequana import sequana_data
rule multiqc:
     input:
        expand(__sequana_coverage__csv, sample=manager.samples),
        expand(__fastqc_samples__output_done, sample=manager.samples),
     output: __multiqc__output
     params:
         config=sequana_data("multiqc_config.yaml", "../multiqc")
     shell: "multiqc . -m sequana_coverage -m fastqc -f -c {params.config}"





rule wes_qc:
    input:
        expected_output


onsuccess:
    from sequana.modules_report.fastqc import FastQCModule

    try:
        print("Create multi summary file")
    except:
        pass

    from sequana.snaketools import OnSuccess
    sm.OnSuccess()() # create instance and execute to create Makefile and cleanup


onerror:
    print("An error occurred. See message above.")

